# Chapter02 리팩토링 원칙

## 2.1 리팩터링 정의

-   79 리팩터링, 리팩터링(하다)
-   80 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 ~ - '재구성 restructuring' ~ - 겉보기 동작 observable behavior - 리팩토링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것.

    <br>

## 2.2 두 개의 모자

    - 소프트웨어를 개발하는 동안 나는 ~

 <br>

## 2.3 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

-   하지만 코드량이 줄면 수정하는 데 ~

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

-   사실 프로그래밍에서는 사람이 가장 중요하지만 ~
-   그러면 코드의 목적이 더 잘 드러나게, ~
-   그래서 기억할 필요가 있는 것들은 ~

### 리팩터링하면 버그를 쉽게 찾을 수 있다

-   "난 띄어난 프로그래머가 아니에요. ~"

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

-   모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. ~
-   설계 지구력 가설 Design Stamina Hypothesis ~

 <br>
 
## 2.4 언제 리팩터링해야 할까?

-   한 시간 간격으로
-   3의 법칙

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

-   코드베이스에 기능을 새로 추가하기 직전
-   "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"
-   준비를 위한 리팩터링 Preparatory refactoring

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

-   나는 코드를 파악할 때마다 그 코드의 의도가 명확하게 ~
-   자잘한 세부 코드에 이해를 위한 리팩터링 Comprehension Refactoring

### 쓰레기 줍기 리팩터링 Litter-Pickup Refactoring

-   시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, ~
-   물론 수정하려면 ~

### 계획된 리팩터링과 수시로 하는 리팩터링

-   대부분의 리팩터링을 다른 일을 ~

-   무언가 수정하려 할 때는 ~
-   뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 ~
-   계획된 리팩터링을 하게 되는 일은 최소한으로 ~

### 오래 걸리는 리팩터링

-   리팩터링은 대부분 몇 분 안에 ~
-   누구든지 리팩터링해야 할 코드와 관련한 작업을 ~
-   추상화로 갈아타기 Branch By Abstraction

### 코드 리뷰에 리팩터링 활용하기

-   내가 경험한 가장 좋은 방법은 ~

### 관리자에게는 뭐라고 말해야 할까?

-   프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.

### 리팩터링하지 말아야 할 때

<br>

## 2.5 리팩터링 시 고려할 문제

-   나는 누가 특정한 기술, 도구, 아키텍처 등을 ~

### 새 기능 개발 속도 저하

-   나는 준비를 위한 리팩터링을 하면 ~
-   반면 내가 직접 건드릴 일이 ~
-   개발팀을 이끌고 있다면 ~
-   리팩터링을 '클린 콛'나 ~
-   리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다. ~

### 코드 소유권

-   내가 선호하는 방식은 코드의 소유권을 ~

### 브랜치

-   반면 '통합'은 마스터를 개인 브랜칠 가져와서 ~
-   지속적 통합 Continuous Integration CI, Trunk-Based Development ~
-   각 기능을 끌 수 있는 토글 ~
-   켄트 백이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍 ~
-   참고로 CI를 적용하는 편이 ~

### 테스팅

-   코드의 다양한 측면을 검사하는 test suite ~
-   self-testing code : https://martinfowler.com/testing/
-   자가 테스트 코드는 리팩터링을 할 수 ~
-   Jay Bazuzi

### 래거시 코드 legacy code

-   대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.
-   그나마 해줄 수 있는 조언은 "레거시 코드 전략"
    -   '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다"
-   내가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 ~
-   코드를 훑게 되는 횟수가 많다는 말은 ~

### 데이터베이스

<br>

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

-   리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 ~
-   한 가지 방법은 ~
-   그저 현재까지 파악한 요구사항만을 해결하는 ~
-   복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 ~
-   리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.
-   이런 식으로 설계하는 방식을 ~, YAGNI는 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이며, ~
-   나는 나중에 문제를 더 깊이 이해하게 ~, 진화형 아키텍쳐

<br>

## 2.7 리팩터링과 소프트웨어 개발 프로세스

-   XP의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 ~, TDD
-   리팩터링의 첫 번째 토대는 자가 테스트 코드다.
-   팀으로 개발하면서 ~
-   리팩터링이 YAGNI의 토대인 동시에 ~ , 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽기 때문이다. ~
-   지속적인 배포는 소프트웨어를 언제든 ~

<br>

## 2.8 리팩터링과 성능

-   내가 성능을 무시하는 이유는 설계의 순수성을 우선시하거나 ~
-   성능 개선을 위한 세 번째 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안~
-   먼저 프로파일러로 프로그램을 분석하여 ~

<br>

## 2.9 리팩터링의 유래

-   1980년대부터 스몰토크를 활용해 ~
-   'GoF 디자인 패턴' 랄프 존슨
-   '리팩터링 브라우저'

<br>

## 2.10 리팩터링 자동화

-   <이맥스>

## 2.11 더 알고 싶다면

-   "리팩터링 워크북" : https://product.kyobobook.co.kr/detail/S000001469794
-   "패턴을 활용한 리택터링" : https://product.kyobobook.co.kr/detail/S000001469867
-   "리팩터링 html" : https://www.yes24.com/Product/Goods/3602596
-   "레거시 코드 활용 전략" : https://product.kyobobook.co.kr/detail/S000001804724

-   https://github.com/WegraLee/Refactoring
-   https://refactoring.com/

-   "리팩터링 자바스크립트" : https://product.kyobobook.co.kr/detail/S000001792730 - 번역이 안좋다.
