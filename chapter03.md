# Chapter 03 <ins>코드에서 나는 악취</ins>

    _ 켄트 백, 마틴 파울러 공저

-   113 ~ 114 : 우리 경ㅓ에 따면 숙련된 사람의 직관만큼 정확한 기준은 없다.

## 3.1 기이한 이름 Mysterious Name

-   114 : 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
    -   6.5 함수 선언 바꾸기, 6.7 변수 이름 바꾸기, 9.2 필드 이름 바꾸기

## 3.2 중복 코드 Duplicated Code

-   115
    -   6.1 함수 추출하기, 8.6 문장 슬라이드하기, 12.1 메서드 올리기

## 3.3 긴 함수 Long Function

-   115 : 간접 호출 indirection의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것

-   115 ~ 116 : 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 코드를 볼 이유가 사라진다. 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 '의도 intention"가 드러나게 짓는다.
-   116 : 심지어 원래 코드보다 길어짇라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 여기서 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.
    -   6.1 함수 추출하기, 7.4 임시 변수를 질의 함수로 바꾸기, 6.8 매개변수 객체 만들기, 11.4 객체 통째로 넘기기
    -   임시 변수와 매개변수가 너무 많다면 11.9 함수를 명령으로 바꾸기
    -   코드를 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
    -   조건문 10.1 조건문 분해하기, swtch case문 6.1 함수 추출하기, 10.4 조건부 로직을 다형성으로 바꾸기
    -   8.7 반복문 쪼개기

## 3.4 긴 매개변수 목록 Long Parameter List

-   11.5 매개변수를 질의 함수로 바꾸기, 11.4 객체 통째로 넘기기, 6.8 매개변수 객체 만들기, 11.3 플래스 인수 제거하기
-   6.9 여러 함수를 클래스로 묶기

## 3.5 전력 데이터 Global Data

-   '유령 같은 원격작용 spooky actions at a distance"
-   118 : 전역 데이터의 대표적인 형태는 전역 변수이지만 클래스 변수와 싱글톤 singleton에서도 같은 문제가 발생한다.
-   6.6 변수 캡슐화하기, ~ 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

## 3.6 가변 데이터 Mutable Data

-   이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.
-   119 : 정해놓은 함수를 거쳐아먄 값을 수정할 수 있또록 하면 어떻게 수정되었는지 감시하거나 코드를 개선하기 쉽다.~
-   값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다.
-   변수를 갱신하는 코드들의 유효범위를 (클래스나 변환 transform으로) 제한한다. ~

## 3.7 뒤엉킨 변경 Divergent Change

-   소프트웨어는 자고로 소프트해야 마땅하기 때문이다. ~ 뒤엉킨 변경과 산탄총 수술 3.8절
-   뒤엉킨 변경은 단일 책임 원칙 Single Responsibility Priciple(SRP)이 제대로 지켜지지 않을 때 나타난다.
    -   120 주석 : 단일 모둘은 하나의 액터에 대해서면 책임져야 한다.
-   120: 데이터베이스체서 데이터를 가져와서 금융 상품 로직에서 ~

## 3.8 산탄총 수술 Shotgun Surgery

-   주석 : 뒤엉킨 변경 vs 산탄총 수술
-   이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.
-   전체 ~

## 3.9 기능 편애 Feature Envy

-   121 : 기능 편애는 흔희 어떤 함수가 자기가 속한 모둘의 함수나 데이터보다 ~
-   전체 ~
-   122 : 가장 기본이 되는 원칙은 '함께 변경ㅎㄹ 대상을 한데 모으는 것'

## 3.10 데이터 뭉치 Data Clumps

-   전체 ~

## 3.11 기본형 집착 Primitive Obsession

-   전체 ~

## 3.12 반복되는 switch문 Repeated switchs

-   124: 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다. 이럴 때 다형성은 ~

## 3.13 반복문 Loops

-   지금은 일급 함수 first-class functions를 지원하는 언어가 많아졌기 때문에 8.8절 반복문을 파이프라인으로 바꾸기 ~

## 3.14 성의 없는 요소 Lazy Element

## 3.15 추측성 일반화 Speculative Generality

-   125 : 당장 걸리적거리는 코드는 눈앞에서 치워버리자.
-   전체 ~

## 3.16 임시 필드 Temporary Field

-   전체 ~

## 3.17 메시지 체인 Message Chains

-   126 : 이는 클라이언트가 객체 네비게이션 구조에 종속됐음을 의미한다.
-   위임 숨기기, 이 팩터링은 메시지 체인의 다양한 연결점에 적용할 수 있다.
-   전체 ~

## 3.18 중개자 Middle Man

-   전체 ~

## 3.19 내부자 거래 Insider Trading

-   전체 ~

## 3.20 거대한 클래스 Large Class

-   128 : 클래스 추출하기 7.5
-   전체 ~

## 3.21 서로 다른 인터페이스의 대안 클래스들 Alternative Classes with Different Interfaces

-   전체 ~

## 3.22 데이터 클래스 Data Class

-   전체 ~

## 3.23 상속 포기 Refused Bequest

-   전체 ~

## 3.24 주석 Comments
