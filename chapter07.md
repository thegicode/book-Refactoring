# Chapter 07 캡슐화

## 7.1 레코드 캡슐화하기 Encapsulate Record

### 배경

    - 나는 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호하는 편이다. 객체를 사용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다. 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다. 캡슐화하면 이름을 바꿀 떄도 좋다. 필드 이름을 바꿔도 기존 이름과 새 이름 모두를 각각의 메서드로 제공할 수 있어서 사용자 모두가 새로운 메서드로 옮겨갈 때까지 점진적으로 수정할 수 있다.

### 절차

    1. -> 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.

### 예시: 중첩된 레코드 캡슐화하기

    - 243 나는 덩치 큰 데이터 구조를 다룰수록 쓰기 부분에 집중한다. 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한 곳에 모아두는 일이 굉장히 중요하다.
    - 244 이 방법의 가장 큰 장점은 customerData의 모든 쓰임을 명시적인 API로 제공한다는 것이다. ... 하지만 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어난다. 요즘 언어들에서는 list-and-hash 데이터 구조를 쉽게 다룰 수 있는데, 이런 언어를 사용한다면 클라이언트에 이 데이터를 이 형태로 넘겨주는 것도 좋다.
        - https://martinfowler.com/bliki/ListAndHash.html
    - 클라이언트가 데이터 구조를 요청할 때 실제 데이터를 제공해도 된다. ... 가장 간단한 방법은 앞에서 작성한 rawData() 메서드를 사용하여 내부 데이터를 복제해서 제공하는 것이다.
        - 데이터 구조가 클수록 복제 비용이 커져서 성능이 느려질 수 있다. ... 나라면 막연히 걱정만 하지 않고 얼마나 영향을 주는지 실제로 측정해본다.
    - 245 또 따른 문제는 클라이언트가 원본을 수정한다고 착각할 수 있다는 것이다. 이럴 때는 읽기전용 프락시를 제공하거나 복제본을 동결시켜서 데이터를 수정하려 할 떄 에러를 던지도록 만들 수 있다.
    -   게터는 데이터 구조를 깊이 탐색하게 만들되 원본 데이터를 그대로 반환하지 않고 객체로 반환하는 게 효과적일 수 있다. "Refactoring Code to Load a Document"에서 자세히 다룬다.
        - https://martinfowler.com/articles/refactoring-document-load.html

<br>

## 7.2 컬렉션 캡슐화하기 Encapsulate Collection

### 배경

-   246 컬렉션을 감싼 클래스에 흔히 add()와 remove()라는 이름의 컬렉션 변경자 메서드를 만든다. 이렇게 항상 컬렉션을 소유한 클래스를 통해서만 원소를 변경하도록 하면 프로그램을 개선하면서 컬렉션 변경 방식도 원하는 대로 수정할 수 있다.
-   247 컬렉션 게터가원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는 게 낫다.
-   컬렉션에 접근하려면 컬렉션이 소속된 클래스의 적절한 메서드를 반드시 거치게 하는 것이다.
    -   Collection Pipeline : https://martinfowler.com/articles/collection-pipeline/
-   또 다른 방법은 컬렉션을 읽기전용으로 제공할 수 있다.
    -   프락시가 내부 컬렉션을 읽는 연산은 그대로 전달하고, 쓰기는 (예외를 던지는 식으로) 모두 막는 것이다.
-   가장 흔히 사용하는 방식은 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.
    -   https://memberservices.informit.com/my_account/webedition/9780135425664/html/principles.html#performance

### 절차

-   248 컬렉션 전체를 통째로 바꾸는 세터는 제거한다. 세터를 제거할 수 없다면 인수로 받은 컬렉션을 복제해 저장하도록 만든다.

### 예시

-   250 세터를 제공해야 할 특별한 이유가 있다면 인수로 받은 컬렉션의 복제본을 필드에 저장하게 한다.
-   내 경험에 따르면 컬렉션에 대해서는 어느 정도 강박증을 갖고 불필요한 복제본을 만드는 편이, 예상치 못한 수정이 촉발한 오류를 디버깅하는 것보다 낫다.
    -   컬렉션 관리를 책임지는 클래스라면 항상 복제본을 제공해야 한다.
    -   그리고 나는 컬렉션을 변경할 가능성이 있는 작업을 할 때도 습관적으로 복제본을 만든다.

<br>

## 7.3 기본형을 객체로 바꾸기 Replace Primitive with Object

## 배경

-   251 나는 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다.
    -   나중에 특별한 동작이 필요해지면 이 클래스에 추가회면 되니 프로그램이 커질수록 점점 유용한 도구가 된다.

## 절차

## 예시

    - 252 레코드 구조에서 데이터를 읽어 들이는 단순한 주문 order 클래스
    - 이 클래스의 우선 순위 priority 속성은 값을 간단히 문자열로 표현한다.
    - 나는 데이터 값을 다루기 전에 항상 변수부터 캡슐화한다.
    - 253 이 상황에서는 개인적으로 게터(value()) 보다는 변환 함수(toString())를 선호한다. 클라이언트 입장에서 보면 속성 자체를 받은 게 아니라 해당 속성을 문자열로 표현한 값을 요청한게 되기 때문이다.
    - 지금처럼 매개변수 이름만으로 세터가 받는 데이터의 유형을 쉽게 알 수 있다면 세터의 이름은 그대로 둬도 좋다.
    - 254 이렇게 하는 목적은 어디까지나 Priority 클래스를 새로운 동작을 담는 장소로 활용하기 위해서다.

<br>

## 7.4 임시 변수를 질의 함수로 바꾸기 Replace Temp with Query

### 배경

-   256 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다.
-   257 변수 대신 함수로 만들어두면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다.
-   이번 리팩터링은 클래스 안에서 적용할 때 효과가 가장 크다.

<br>

## 7.5 클래스 추출하기 Extract Class

## 배경

-   260 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다. 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다. 특정 데이터나 메서드 일부를 제거하면 어떤 일이 일어나는지 자문해보면 판단에 도움이 된다. 제거해도 다른 필드나 메서드 들이 논리적으로 문제가 없다면 분리할 수 있다는 뜻이다.
-   263 전화번호는 여러모로 쓸모가 많으니 이 클래스는 클라이언트에게 공개하는 것이 좋겠다.

<br>

## 7.6 클래스 인라인하기 Inline Class

## 배경

-   264 나는 더 이상 제 역할을 못해서 그대로 두면 안 되는 클래스는 인라인해버린다. 역할을 옮기는 리팩터링을 하고 나니 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생긴다.
-   두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인한다. 클래스를 인라인해서 하나로 합친 다음 새로운 클래스를 추출하는 게 쉬울 수도 있기 때문이다.

<br>

## 7.7 위임 숨기기 Hide Delegate

## 배경

-   268 모듈화 설계를 제대로 하는 핵심은 캡슐화다. 어쩌면 가장 중요한 요소일 수도 있다. 캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 캡슐화가 잘 되어 있다면 무언가를 변경해야 할 때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기가 훨씬 쉬워진다.
-   이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다. 그러면 위임 객체가 수정되더라도 서버 코드만 고치면 되며, 클라이언트는 아무런 영향을 받지 않는다.

## 예시

-   270 클라이언트는 부서 클래스의 작동 방식, 다시 말해 부서 클래스가 관리자 정보를 제공한다는 사실을 알아야 한다.
-   이러한 의존성을 줄이려면 클라이언트가 부서 클래스를 볼 수 없게 숨기고, 대신 사람 클래스에 간단한 위임 메서드를 만들면 된다.

<br>

## 7.8 중개자 제거하기 Remove Middle Man

-   271 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 하는데, 이렇게 기능을 추가하다 보면 단순히 전달만 하는 위임 메서드들이 점점 성가셔진다.
-   272 어느 정도까지 숨겨야 적절한지를 판단하기란 쉽지 않지만 ... 시스템이 바뀌면 '적절하다'의 기준도 바뀌기 마련이다.
-   이런 위임 메서드가 많아지면 사람 클래스의 상당 부분이 그저 위임하는 데만 쓰일 것이다. 그럴 때는 중개자를 제거하는 편이 낫다.
-   273 위임 숨기기나 중개자 제거하기를 적당히 섞어도 된다. 자주 쓰는 위임은 그대로 두는 편이 클라이언트 입장에서 편하다.
-   자동 리팩터링?

<br>

## 7.9 알고리즘 교체하기 Substitute Algorithm
