# Chapter 07 캡슐화

## 7.1 레코드 캡슐화하기 Encapsulate Record

### 배경

    - 나는 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호하는 편이다. 객체를 사용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다. 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다. 캡슐화하면 이름을 바꿀 떄도 좋다. 필드 이름을 바꿔도 기존 이름과 새 이름 모두를 각각의 메서드로 제공할 수 있어서 사용자 모두가 새로운 메서드로 옮겨갈 때까지 점진적으로 수정할 수 있다.

### 절차

    1. -> 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.

### 예시: 중첩된 레코드 캡슐화하기

    - 243 나는 덩치 큰 데이터 구조를 다룰수록 쓰기 부분에 집중한다. 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한 곳에 모아두는 일이 굉장히 중요하다.
    - 244 이 방법의 가장 큰 장점은 customerData의 모든 쓰임을 명시적인 API로 제공한다는 것이다. ... 하지만 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어난다. 요즘 언어들에서는 list-and-hash 데이터 구조를 쉽게 다룰 수 있는데, 이런 언어를 사용한다면 클라이언트에 이 데이터를 이 형태로 넘겨주는 것도 좋다.
        - https://martinfowler.com/bliki/ListAndHash.html
    - 클라이언트가 데이터 구조를 요청할 때 실제 데이터를 제공해도 된다. ... 가장 간단한 방법은 앞에서 작성한 rawData() 메서드를 사용하여 내부 데이터를 복제해서 제공하는 것이다.
        - 데이터 구조가 클수록 복제 비용이 커져서 성능이 느려질 수 있다. ... 나라면 막연히 걱정만 하지 않고 얼마나 영향을 주는지 실제로 측정해본다.
    - 245 또 따른 문제는 클라이언트가 원본을 수정한다고 착각할 수 있다는 것이다. 이럴 때는 읽기전용 프락시를 제공하거나 복제본을 동결시켜서 데이터를 수정하려 할 떄 에러를 던지도록 만들 수 있다.
    -   게터는 데이터 구조를 깊이 탐색하게 만들되 원본 데이터를 그대로 반환하지 않고 객체로 반환하는 게 효과적일 수 있다. "Refactoring Code to Load a Document"에서 자세히 다룬다.
        - https://martinfowler.com/articles/refactoring-document-load.html
