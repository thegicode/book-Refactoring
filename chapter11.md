# Chapter 11 API 리팩터링

-   모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이 블록들을 끼워 맞추는 연결부다.
-   좋은 API는 데이터를 갱신하는 함수와 그저 조회만 하는 함수를 명확히 구분한다.
    -   두 기능이 섞여 있다면 질의 함수와 변경 함수 분리하기를 적용해 갈라놔야 한다.
    -   값 하나 때문에 여러 개로 나뉜 함수들은 함수 매개변수화하기를 적용해 하나로 합칠 수 있다.
    -   한편, 어떤 매개변수는 그저 함수의 동작 모드를 전환하는 용도로만 쓰이는데, 이럴 때는 플래그 인수 제거하기를 적용하면 좋다.
-   데이터 구조가 함수 사이를 건너 다니면서 필요 이상으로 분해될 때는 객체 통째로 넘기기를 적용해 하나로 유지하면 깔끔해진다.
    -   매개변수를 질의 함수로 바꾸기, 질의 함수를 매개변수로 바꾸기
-   클래스는 대표적인 모듈이다.
    -   내가 만든 객체가 되도록 불변이길 원하므로 기회가 될 때마다 세터 제거하기를 적용한다.
    -   호출자에 새로운 객체를 만들어 반환하려 할 때 일반적인 생성자의 능력만으로는 부족할 때가 있다.
        -   이럴 때 생성자를 팩터리 함수로 바꾸기가 좋은 해법일 수 있다.
-   수많은 데이터를 받는 복잡한 함수를 잘게 쪼개는 문제
    -   함수를 명령으로 바꾸기, 명령을 함수로 바꾸기

<br>

## 11.1 질의 함수와 변경 함수 분리하기 Seperate Query from Modifier

### 배경

-   질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다. 명령-질의 분리(command-query separation)
-   값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하여 시도한다.
-   흔히 쓰는 최적화 기법 중 요청된 값을 캐시해두고 다음번 호출 때 빠르게 응답하는 방법이 있는데. 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는 관찰할 수 없다.
    -   즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

### 예시

-   훑어 악당 miscreant을 찾는 함수
-   악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다.
-   가장 먼저 찾은 악당만 취급한다.

-   [SeperateQueryFromModifier.js](./src/chp11/SeperateQueryFromModifier.js)
-   [SeperateQueryFromModifier.test.js](./test/chp11/SeperateQueryFromModifier.test.js)

<br>
