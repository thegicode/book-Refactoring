# Chapter 11 API 리팩터링

-   모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이 블록들을 끼워 맞추는 연결부다.
-   좋은 API는 데이터를 갱신하는 함수와 그저 조회만 하는 함수를 명확히 구분한다.
    -   두 기능이 섞여 있다면 질의 함수와 변경 함수 분리하기를 적용해 갈라놔야 한다.
    -   값 하나 때문에 여러 개로 나뉜 함수들은 함수 매개변수화하기를 적용해 하나로 합칠 수 있다.
    -   한편, 어떤 매개변수는 그저 함수의 동작 모드를 전환하는 용도로만 쓰이는데, 이럴 때는 플래그 인수 제거하기를 적용하면 좋다.
-   데이터 구조가 함수 사이를 건너 다니면서 필요 이상으로 분해될 때는 객체 통째로 넘기기를 적용해 하나로 유지하면 깔끔해진다.
    -   매개변수를 질의 함수로 바꾸기, 질의 함수를 매개변수로 바꾸기
-   클래스는 대표적인 모듈이다.
    -   내가 만든 객체가 되도록 불변이길 원하므로 기회가 될 때마다 세터 제거하기를 적용한다.
    -   호출자에 새로운 객체를 만들어 반환하려 할 때 일반적인 생성자의 능력만으로는 부족할 때가 있다.
        -   이럴 때 생성자를 팩터리 함수로 바꾸기가 좋은 해법일 수 있다.
-   수많은 데이터를 받는 복잡한 함수를 잘게 쪼개는 문제
    -   함수를 명령으로 바꾸기, 명령을 함수로 바꾸기

<br>

## 11.1 질의 함수와 변경 함수 분리하기 Seperate Query from Modifier

### 배경

-   질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다. 명령-질의 분리(command-query separation)
-   값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하여 시도한다.
-   흔히 쓰는 최적화 기법 중 요청된 값을 캐시해두고 다음번 호출 때 빠르게 응답하는 방법이 있는데. 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는 관찰할 수 없다.
    -   즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

### 예시

-   훑어 악당 miscreant을 찾는 함수
-   악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다.
-   가장 먼저 찾은 악당만 취급한다.

-   [SeperateQueryFromModifier.js](./src/chp11/SeperateQueryFromModifier.js)
-   [SeperateQueryFromModifier.test.js](./test/chp11/SeperateQueryFromModifier.test.js)

<br>

## 11.2 함수 매개변수화하기 Parameterize Function

### 배경

-   두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다.

### 예시

-   [ParameterizeFunction.js](./src/chp11/ParameterizeFunction.js)
-   [ParameterizeFunction.test.js](./test/chp11/ParameterizeFunction.test.js)

<br>

## 11.3 플래그 인수 제거하기 Remove Flag Argument

### 배경

-   플래그 인수 flag argument란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다.
-   플래그 인수를 싫어하는 이유
    -   호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워지기 때문이다.
-   특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다.
-   플래그 인수가 되려면
    -   호출하는 쪽에서 불리언 값으로 (프로그램에서 사용되는 데이터가 아닌) 리터럴 값을 건네야 한다.
    -   또한 호출되는 함수는 그 인수를 (다른 함수에서 전달하는 데이터가 아닌) 제어 흐름을 결정하는 데 사용해야 한다.
-   플래그 인수를 제거하면 코드가 깔끔해짐은 물론 프로그래밍 도구에도 도움을 준다.
-   함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수를 써야 하는 합당한 근거가 될 수 있다.
    -   같은 로직을 조합해내는 더 간단한 함수를 만들 방법을 고민

### 예시

-   [RemoveFlagArgument.js](./src/chp11/RemoveFlagArgument.js)

### 예시 : 매개변수를 까다로운 방식으로 사용할 때

-   [RemoveFlagArgument2.js](./src/chp11/RemoveFlagArgument2.js)

<br>

## 11.4 객체 통째로 옮기기 Preserve Whole Object

-   하나의 레코드에서 값 두어 개를 가져와 인수로 넘기는 코드를 보면, 그 값들 대신 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다.
-   레코드틀 통째로 넘기면 변화에 대응하기 쉽ㄴ다.
-   어떤 객체로부터 값 몇 개를 얻은 후 그 값들만으로 무언가를 하는 로직이 있다면, 그 로직을 객체 안으로 집어넣어야 함을 알려주는 악취로 봐야 한다.
    -   그래서 객체 통째로 넘기기는 특히 매개변수 객체 만들기 6.8절 후, 즉 산재한 수많은 데이터 더미를 새로운 객체로 묶은 후 적용하곤 한다.
-   한편, 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출하라는 신호일 수 있다.
-   많은 사람이 놓치는 사례가 하나 더 있다. 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우다.
    -   이런 상황이면 데이터 여러 개 대신 객체 자신의 참조만 건네도록 수정할 수 있다 (자바스크립트라면 this를 건넬 것이다).

### 예시

-   [PreserveWholeObject.js](./src/chp11/PreserveWholeObject.js)

### 예시 : 새 함수를 다른 방식으로 만들기

-   [PreserveWholeObject2.js](./src/chp11/PreserveWholeObject2.js)

<br>

## 11.5 매개변수를 질의 함수로 바꾸기 Replace Parameter with Query

### 배경

-   매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 변화를 줄 수 있는 일차적인 수단이다.
    -   다른 코드와 마찬가지로 이 목록에서도 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽다.
-   피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다.
    -   이런 함수를 호출할 때 매개변수의 값은 호출자가 정하게 되는데, 이 결정은 하지 않아도 되었을 일이니 의미 없이 코드만 복잡해질 뿐이다.
-   이번 리팩터링의 한계는 '쉽게'라는 단어에 있다. 해당 매개변수를 제거하면 값을 결정하는 책임 주체가 달라진다.
    -   매개변수가 있다면 결정 주체가 호출자가 되고, 매개변수가 없다면 피호출 함수가 된다.
    -   습관적으로 호출하는 쪽을 간소하게 만든다.
    -   즉, 책임 소재를 피호출 함수로 옮긴다는 뜻인데, 물론 피호출 함수가 그 역할을 수행하히게 적합할 때만 그렇게 한다.

### 예시

-   [ReplaceParameterWithQuery.js](./src/chp11/ReplaceParameterWithQuery.js)

<br>

## 11.6 질의 함수를 매개변수로 바꾸기 Replace Query with Parameter

### 배경

-   함수 안에 두기엔 거북한 참조를 발견할 때가 있다.

    -   전역 변수를 참조한다거나 (같음 모듈에 안에서라도) 제거하길 원하는 원소를 참조하는 경우기ㅏ 여기 속한다.
    -   이 문제는 해당 참조를 매개변수로 바꿔 해결할 수 있다. 참조를 풀어내는 책임을 호출자로 옮기는 것이다.

-   똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다.

    -   이런 성질을 '참조 투명성'이라 한다.
    -   참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다.
    -   책임이 호출자로 옮겨진다는 점을 고랴해야 하지만, 모듈을 참조 투명하게 만들어 얻는 장점은 대체로 아주 크다.
    -   그래서 모듈을 개발할 때 순수 함수들을 따로 구분하고, 프로그램의 입출력과 기타 가변 원소들을 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이 활용한다.
    -   그리고 이번 리팩터링을 활용하면 프로그램의 일부를 순수 함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트하거나 다루기가 쉬워진다.

-   단점 : 질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 한다.
    -   결국 호출자가 복잡, 이왕이면 고객(호출자의)의 삶이 단순해지도록 설계하지는 지론과 배치된다.
    -   이 문제는 결국 책임 소재를 프로그램의 어디에 배정하느냐의 문제로 귀결된다.
    -   정답이 있는 것은 아니다.
    -   프로젝트를 진행하면서 균형점이 이리저리 옮겨질 수 있으니 이 리팩터링(과 그 반대 리팩터링)과는 아주 친해져야 한다.

### 예시

-   [ReplaceQueryWithParameter.js](./src/chp11/ReplaceQueryWithParameter.js)

-   이 리팩터링을 수행하면 호출하는 쪽 코드는 전보다 다루기 어려워지는게 보통이다.
-   그런데 이 리팩터링으로 얻은 것이 온도조절기 객체와의 결합을 제거한 것만은 아니다.

    -   HeatingPlan 클래스는 불변이 되었다.
    -   모든 필드가 생성자에서 설정되며, 필드를 변경할 수 있는 메서드는 없다.
    -   난방 계획도 불변이므로 온도조절기 참조를 메서드 밖으로 옮긴 것이 targetTemperature()를 참조 투명하게 만들어준다.
    -   따라서 같은 객체의 targetTemperature()에 같은 인수를 넘겨 호출하면 언제나 똑같은 결과를 돌려줄 것이다.

-   [자바스크립트와 불변 클래스]
    자바스크립트의 클래스 모델에서는 객체 안의 데이터를 직접 얻어낼 방법이 항상 존재하기 때문에 불변 클래스임을 보장하는 수단이 없다는 문제가 있다.
    하지만 클래스를 불변으로 설계했음을 알리고 그렇게 사용하라고 제안하는 것만으로 충분한 값어치를 할 때가 많다.
    클래스에 불변 성격을 부여하는 건 훌륭한 전략이며, 질의 함수를 매개변수로 바꾸기 리팩터링은 이 전략을 실행하는 데 큰 도움이 된다.

<br>

## 11.7 세터 제거하기 Remove Setting Method

### 배경

-   세터 메서드가 있다고 함은 필드가 수정될 수 있다는 뜻이다.
    -   객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않았을 것이다.
    -   그러면 해당 필드는 오직 생성자에서만 설정되며, 수정하지 않겠다는 의도가 명명백백해지고, 변경될 가능성이 봉쇄된다.
-   세터 제거하기 리팩터링이 필요한 상황은 주로 두 가지
    -   첫째, 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다.
        -   심지어 생성자 안에서도 말이다.
    -   두 번째, 클라이언트에서 생성 스크립트 creation script 를 사용해 객체를 생성할 때다.
        -   생성 스크립트란 생성자를 호출한 후 일련의 세터를 호출하여 객체를 완성하는 형태의 코드를 말한다.
        -   그러며서 설계자는 스크립트가 완료된 뒤로는 그 객체의 필드 일부(혹은 전체)는 변경되지 않으리라 기대한다.
        -   즉, 해당 세터들은 처음 생성할 때만 호출되리라 가정한다.

### 예시

-   [RemoveSettingMethod.js](./src/chp11/RemoveSettingMethod.js)

<br>

## 11.8 생성자를 팩터리 함수로 바꾸기 Replace Constructor with Factory Function

### 배경

-   많은 객체 지향 언어에서 제공하는 생성자는 객체를 초기화하는 특별한 용도의 함수다.
    -   하지만 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 한다.
    -   가령 자바 생성자는 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다.
    -   생성자의 이름도 고정되어, 기본 이름보다 더 적절한 이름이 있어도 사용할 수 없다.
    -   생성자를 호출하려면 특별한 연산자(new)를 사용해야 해서 일반 함수가 오길 기대하는 자리에는 쓰기 어렵다.
-   팩터리 함수에는 이런 제약이 없다.
    -   팩터리 함수를 구현하는 과정에서 생성자를 호출할 수는 있지만, 원한다면 다른 무언가로 대체할 수 있다.

### 예시

-   [ReplaceConstructorWithFactoryFunction.js](./src/chp11/ReplaceConstructorWithFactoryFunction.js)
-   [ReplaceConstructorWithFactoryFunction.test.js](./test/chp11/ReplaceConstructorWithFactoryFunction.test.js)

### ChatGPT : 팩터리 함수란?

팩터리 함수(Factory Function)란 객체를 생성하고 반환하는 함수를 의미합니다. 일반적으로, 이러한 함수는 새 객체를 직접적으로 new 키워드를 사용해 생성하는 대신에 사용됩니다. 팩터리 함수를 사용하는 주된 이유는 객체 생성 과정을 추상화하여, 객체 생성 시 필요한 로직이나 초기 설정을 캡슐화하고, 객체의 인스턴스를 유연하게 관리하기 위함입니다.

팩터리 함수의 장점은 다음과 같습니다:

유연성: 객체를 생성할 때, 다양한 설정이나 조건에 따라 다른 타입의 객체를 반환할 수 있습니다. 이는 같은 인터페이스나 부모 클래스를 가진 다양한 객체를 조건에 따라 생성하고 관리할 수 있게 해줍니다.

간결성: 클라이언트 코드에서는 객체 생성에 필요한 복잡한 초기화 과정을 알 필요 없이, 단순히 팩터리 함수를 호출함으로써 필요한 객체를 얻을 수 있습니다.

추상화: 팩터리 함수는 객체 생성 로직을 숨기며, 사용자에게는 필요한 인터페이스만 노출합니다. 이로 인해 내부 구현 변경에 대한 유연성이 증가합니다.

명시성: 함수 이름을 통해 생성하려는 객체의 용도나 특성을 명시적으로 표현할 수 있습니다.
