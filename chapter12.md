# Chapter 12 상속(inheritance) 다루기

-   객체 지향 프로그로밍에서 가장 유명한 특성인 상속
    -   다른 강력한 메커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.
    -   더욱이 상속은 발등에 불이 떨어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다.

<br>

## 12.1 메서드 올리기 Pull Up Method

-   메서드 올리기를 적용학기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다.

### 예시

-   [PullUPMethod.js](./src/chp12/PullUPMethod.js)

<br>

## 12.2 필드 올리기 Pull Up Field

### 배경

-   서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕 있다.

    -   특히 필드가 중복되기 쉽다.
    -   이런 필드들은 이름이 비슷한 게 보통이지만, 항상 그런 것은 아니다.
    -   그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어덯게 이용되는지 분석해봐야 한다.
    -   분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.

-   이렇게 하면 두 가지 중복을 줄일 수 있다.
    -   첫째, 데이터 중복 선언을 없앨 수 있다.
    -   둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.
-   동적 언어 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 많다.
    -   그 대신 필드에 가장 처음 값이 대입될 때 등장한다.
    -   이런 경우라면 필드를 올리기 전에는 반드시 생성자 본문부터 올려야(12.3절) 한다.

<br>

## 12.3 생성자 본문 올리기 Pull Up Constructor Body

### 배경

-   생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
-   나는 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기(6.1절)와 메서드 올리기(12.1절)를 차례로 적용하여 말끔히 수퍼클래스로 옮기곤 한다.
    -   그런데 그 메서드가 생성자라면 스텝이 꼬인다.
    -   생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

### 예시

[PullUpConstructorBody.js](./src/chp12/PullUpConstructorBody.js)

### 예시: 공통 코드가 나중에 올 때

-   생성자는 대부분 (super()를 호출하여) 공동 작업을 먼저 처리한 다음, 각 서브클래스에 필요한 추가 작업을 처리하는 식으로 동작한다.
    -   그런데 이따금 곹옹 작업이 뒤에 오는 경우도 있다.

[PullUpConstructorBody2.js](./src/chp12/PullUpConstructorBody2.js)

<br>

## 12.4 메서드 내리기 Push Down Method

### 배경

-   특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브 클래스(들)에 축하는 편이 깔끔하다.
-   다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무언인지를 호출자가 알고 있을 때만 적용할 수 있다.
-   그렇지 못한 상황이라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야 (10.4절) 한다.

<br>

## 12.5 필드 내리기 Push Down Field

### 배경

-   서브클래스 하나(혹은 소수)에서만 사용되는 필드는 해당 서브클래스(들)로 옮긴다.

<br>

## 12.6 타입 코드를 서브클래스로 바꾸기 Replace Type Code with Subclasses

### 배경

-   소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있따.
    -   예) 직원을 담당 업무로 구분하거나(엔지니어, 관리자, 영업자 등) 주문을 시급성으로 구분하기도 한다. (급함, 보통 등)
    -   이런 일을 다루는 수단으로는 타입 코드 type code 필드가 있다.
    -   타입 코드는 프로그래밍 언어데 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
-   타입 코드만으로는 특별히 불편한 상황은 별로 없지만 그 이상의 무언가가 필요할 때가 있다.
    -   여기서 '그 이상'이라 하면 바로 서브클래스를 가리킨다.
-   서브클래스는 두 가지 면에서 특히 맥력적이다.

    1.  첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.
        -   타입 코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용하다.
        -   서브클래스를 이용하면 이런 함수들에 조건부 로직을 다형성으로 바꾸기(10.4절)를 적용할 수 있다.
    2.  특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.
        -   예컨대 '판매 목표'는 '영업자' 유형일 때만 의미가 있다. 이런 상황이라면 서브클래스를 만들고 필요한 서브클래스만 필드를 갖도록 정리하자(필드 내리기 12.5절).
        -   물론 타입 코드를 사용할 때도 타입과 값이 올바르게 짝지어 사용되는지 검증하는 코드를 넣을 수 있지만, 서브클래스 방식이 관계를 더 명확히 드러낸준다.

-   이번 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다.
    -   예컨대 전자 방식이라면 직원의 하위 타입인 엔지니어를 만들 것이다.
        반면 후자는 직원에게 직원 유형 '속성'을 부여하고, 이 속성을 클래스로 정의해 엔지니어 속성과 관리자 속성 같은 서브클래스를 만드는 식이다.
    -   대상 클래스를 직접 서브클래싱하는 게 간단하지만 업무 유형을 다른 용도로 쓰고 싶을 때 그럴 수 없다는 단점이 있다.
    -   또한 유형이 불변일 때도 직접 서브클래싱 방식은 이용할 수 없다.
    -   서브클래싱 대상을 직원 유형 속성에 적용하고자 한다면 먼저 타입 코드에 기본형을 객체로 바꾸기(7.3절)를 적용하여 직원 유형 클래스를 만든 다음, 이 클래스에 이번 리팩터링을 적용하면 된다.

### 예시: 직접 상속할 때

[ReplaceTypeCodeWithSubclasses.js](./src/chp12/ReplaceTypeCodeWithSubclasses.js)

### 예시 : 간접 상속할 때

[ReplaceTypeCodeWithSubclasses2.js](./src/chp12/ReplaceTypeCodeWithSubclasses2.js)

<br>

## 12.7 서브클래스 제거하기 Remove Subclass

### 배경

-   서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다.
    -   다름을 프로그래밍하는 멋진 수단인 것이다.
    -   하지만 소프트웨어 시스템이 성장함에 따라 서브클래스로 만든 변동이 다른 모듈로 이동하거나 완전히 사라지기도 하면서 가치가 바래기도 한다.
    -   서브클래스는 결국 한 번도 활용되지 않기도 하며, 때론 서브클래스를 필요로 하지 않는 방식으로 만들어진 기능에서만 쓰이기도 한다.
-   더 이상 쓰이지 않는 서브클래스와 마주하는 프로그래머는 가치 없는 것을 이해하느라 에너지를 낭비할 것이다.
    -   이런 정도까지 되면 서브클래스를 슈퍼클래스의 필드로 대체해 제거하는 게 최선이다.
-   이 리팩터링은 다수의 서브클래스에 한꺼번에 적용할 때가 많다. 그럴 때는 팩터리 함수를 추가하고 타입 검사 코드를 옮기는 캡슐화 단계들을 먼저 실행한 다음 개별 서브클래스를 하나씩 슈퍼클래스로 흡수시킨다.

### 얘시

[RemoveSubclass.js](./src/chp12/RemoveSubclass.js)

<br>

## 12.8 슈퍼클래스 추출하기 Extract Superclass

### 배경

-   비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다.
    -   공통된 부분이 데이터라면 필드 올리기(12.2절)를 활용하고, 동작이라면 메서드 올리기(12.1절)를 활용하면 된다.
-   객체 지향을 설명할 때 상속 구조는 '현실 세계에서 활용하는 어떤 분류 체계에 기초하여 구현에 들어가기 앞서 부모 저식 관계를 신중하게 설계해야 한다'라고 이야기하는 사람이 많다.
    -   현실 세계의 이런 분류 체계는 상속을 적용하는 데 힌트가 될 수 있다.
    -   하지만 내 경험에 비춰보자면 상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦았다.
-   슈퍼클래스 추출하기의 대안으로는 클래스 추출하기(7.5절)가 있다.
    -   어느 것을 선택하느냐는 중복 동작을 상속으로 해결하느냐 위임으로 해결하느냐에 달렸다.
-   슈퍼클래스 추출하기 방법이 더 간단할 경우가 많으니 이 리팩터링을 먼저 시도해보시길 권한다.
    -   나중에라도 필요해지면 슈퍼클래스를 위임으로 바꾸기(12.11절)는 어렵지 않다.

### 예시

    [ExtractSuperclass.js](./src/chp12/ExtractSuperclass.js)

<br>

## 12.9 계층 합치기 Collapse Hierachy

### 배경

-   클래스 계층구조를 리팩터링하다 보면 기능들을 위로 올리거나 아래로 내리는 일은 다반사로 벌어진다.
    -   예컨대 계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다.
    -   바로 그 둘을 하나로 합쳐야 할 시점이다.

<br>

## 12.10 서브클래스를 위임으로 바꾸기 Replace Subclass with Delegate

### 배경

-   속한 갈래에 따라 동작이 달라지는 객체들은 상속으로 표현하는 게 자연스럽다.
    -   공통 데이터와 동작은 모두 슈퍼클래스에 두고 서브클래스는 자신에 맞게 기능을 추가하거나 오버라이드하면 된다.
    -   객체 지향 언어로는 이런 형태로 구현하기가 쉽기 때문에 흔히 활용되는 메커니즘이다.
-   하지만 상속에는 단점이 있다.
    -   가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다.
    -   예컨대 사람 객체의 동작을 '나이대'와 '소둑 수준'에 따라 달리 하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘 다는 안된다.
-   또 다른 문제로, 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.
    -   부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽기 때문에 각별히 주의해야 한다.
-   위임 delegate 은 이상의 두 문제를 모두 해결해준다.
    -   다양한 클래스에서 서로 다른 이유로 위임할 수 있다.
    -   위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의 할 수 있다.
    -   즉, 상속보다 결합도가 훨씬 약하다.
    -   그래서 서브클래싱(상속) 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 한다.
-   유명한 원칙이 하나 있다. "(클래스) 상속보다는 (객체) 컴포지션을 사용하라!"
    -   여기서 컴포지션 compositon은 사실상 위임과 같은 말이다.
    -   그래서 처음에는 상속으로 접근한 다음, 문제가 생기기 시작하면 위임으로 갈아탄다.
-   "디자인 패턴" : '서브클래스를 상태 패턴 State Pattern이나 전략 패턴 Strategy Pattern"으로 대체

### 예시 : 서브클래스가 하나일 때
