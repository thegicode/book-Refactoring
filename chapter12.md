# Chapter 12 상속(inheritance) 다루기

-   객체 지향 프로그로밍에서 가장 유명한 특성인 상속
    -   다른 강력한 메커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.
    -   더욱이 상속은 발등에 불이 떨어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다.

<br>

## 12.1 메서드 올리기 Pull Up Method

-   메서드 올리기를 적용학기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다.

### 예시

-   [PullUPMethod.js](./src/chp12/PullUPMethod.js)

<br>

## 12.2 필드 올리기 Pull Up Field

### 배경

-   서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕 있다.

    -   특히 필드가 중복되기 쉽다.
    -   이런 필드들은 이름이 비슷한 게 보통이지만, 항상 그런 것은 아니다.
    -   그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어덯게 이용되는지 분석해봐야 한다.
    -   분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.

-   이렇게 하면 두 가지 중복을 줄일 수 있다.
    -   첫째, 데이터 중복 선언을 없앨 수 있다.
    -   둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.
-   동적 언어 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 많다.
    -   그 대신 필드에 가장 처음 값이 대입될 때 등장한다.
    -   이런 경우라면 필드를 올리기 전에는 반드시 생성자 본문부터 올려야(12.3절) 한다.

<br>

## 12.3 생성자 본문 올리기 Pull Up Constructor Body

### 배경

-   생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
-   나는 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기(6.1절)와 메서드 올리기(12.1절)를 차례로 적용하여 말끔히 수퍼클래스로 옮기곤 한다.
    -   그런데 그 메서드가 생성자라면 스텝이 꼬인다.
    -   생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

### 예시

[PullUpConstructorBody.js](./src/chp12/PullUpConstructorBody.js)

### 예시: 공통 코드가 나중에 올 때

-   생성자는 대부분 (super()를 호출하여) 공동 작업을 먼저 처리한 다음, 각 서브클래스에 필요한 추가 작업을 처리하는 식으로 동작한다.
    -   그런데 이따금 곹옹 작업이 뒤에 오는 경우도 있다.

[PullUpConstructorBody2.js](./src/chp12/PullUpConstructorBody2.js)
