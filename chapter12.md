# Chapter 12 상속(inheritance) 다루기

-   객체 지향 프로그로밍에서 가장 유명한 특성인 상속
    -   다른 강력한 메커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.
    -   더욱이 상속은 발등에 불이 떨어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다.

<br>

## 12.1 메서드 올리기 Pull Up Method

-   메서드 올리기를 적용학기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다.

### 예시

-   [PullUPMethod.js](./src/chp12/PullUPMethod.js)

<br>

## 12.2 필드 올리기 Pull Up Field

### 배경

-   서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕 있다.

    -   특히 필드가 중복되기 쉽다.
    -   이런 필드들은 이름이 비슷한 게 보통이지만, 항상 그런 것은 아니다.
    -   그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어덯게 이용되는지 분석해봐야 한다.
    -   분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.

-   이렇게 하면 두 가지 중복을 줄일 수 있다.
    -   첫째, 데이터 중복 선언을 없앨 수 있다.
    -   둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.
-   동적 언어 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 많다.
    -   그 대신 필드에 가장 처음 값이 대입될 때 등장한다.
    -   이런 경우라면 필드를 올리기 전에는 반드시 생성자 본문부터 올려야(12.3절) 한다.

<br>

## 12.3 생성자 본문 올리기 Pull Up Constructor Body

### 배경

-   생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
-   나는 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기(6.1절)와 메서드 올리기(12.1절)를 차례로 적용하여 말끔히 수퍼클래스로 옮기곤 한다.
    -   그런데 그 메서드가 생성자라면 스텝이 꼬인다.
    -   생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

### 예시

[PullUpConstructorBody.js](./src/chp12/PullUpConstructorBody.js)

### 예시: 공통 코드가 나중에 올 때

-   생성자는 대부분 (super()를 호출하여) 공동 작업을 먼저 처리한 다음, 각 서브클래스에 필요한 추가 작업을 처리하는 식으로 동작한다.
    -   그런데 이따금 곹옹 작업이 뒤에 오는 경우도 있다.

[PullUpConstructorBody2.js](./src/chp12/PullUpConstructorBody2.js)

<br>

## 12.4 메서드 내리기 Push Down Method

### 배경

-   특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브 클래스(들)에 축하는 편이 깔끔하다.
-   다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무언인지를 호출자가 알고 있을 때만 적용할 수 있다.
-   그렇지 못한 상황이라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야 (10.4절) 한다.

<br>

## 12.5 필드 내리기 Push Down Field

### 배경

-   서브클래스 하나(혹은 소수)에서만 사용되는 필드는 해당 서브클래스(들)로 옮긴다.

<br>

## 12.6 타입 코드를 서브클래스로 바꾸기 Replace Type Code with Subclasses

### 배경

-   소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있따.
    -   예) 직원을 담당 업무로 구분하거나(엔지니어, 관리자, 영업자 등) 주문을 시급성으로 구분하기도 한다. (급함, 보통 등)
    -   이런 일을 다루는 수단으로는 타입 코드 type code 필드가 있다.
    -   타입 코드는 프로그래밍 언어데 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
-   타입 코드만으로는 특별히 불편한 상황은 별로 없지만 그 이상의 무언가가 필요할 때가 있다.
    -   여기서 '그 이상'이라 하면 바로 서브클래스를 가리킨다.
-   서브클래스는 두 가지 면에서 특히 맥력적이다.

    1.  첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.
        -   타입 코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용하다.
        -   서브클래스를 이용하면 이런 함수들에 조건부 로직을 다형성으로 바꾸기(10.4절)를 적용할 수 있다.
    2.  특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.
        -   예컨대 '판매 목표'는 '영업자' 유형일 때만 의미가 있다. 이런 상황이라면 서브클래스를 만들고 필요한 서브클래스만 필드를 갖도록 정리하자(필드 내리기 12.5절).
        -   물론 타입 코드를 사용할 때도 타입과 값이 올바르게 짝지어 사용되는지 검증하는 코드를 넣을 수 있지만, 서브클래스 방식이 관계를 더 명확히 드러낸준다.

-   이번 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다.
    -   예컨대 전자 방식이라면 직원의 하위 타입인 엔지니어를 만들 것이다.
        반면 후자는 직원에게 직원 유형 '속성'을 부여하고, 이 속성을 클래스로 정의해 엔지니어 속성과 관리자 속성 같은 서브클래스를 만드는 식이다.
    -   대상 클래스를 직접 서브클래싱하는 게 간단하지만 업무 유형을 다른 용도로 쓰고 싶을 때 그럴 수 없다는 단점이 있다.
    -   또한 유형이 불변일 때도 직접 서브클래싱 방식은 이용할 수 없다.
    -   서브클래싱 대상을 직원 유형 속성에 적용하고자 한다면 먼저 타입 코드에 기본형을 객체로 바꾸기(7.3절)를 적용하여 직원 유형 클래스를 만든 다음, 이 클래스에 이번 리팩터링을 적용하면 된다.

### 예시: 직접 상속할 때

[ReplaceTypeCodeWithSubclasses.js](./src/chp12/ReplaceTypeCodeWithSubclasses.js)

### 예시 : 간접 상속할 때

[ReplaceTypeCodeWithSubclasses2.js](./src/chp12/ReplaceTypeCodeWithSubclasses2.js)
